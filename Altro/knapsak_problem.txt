Abbiamo 'm' oggetti, ogni oggetto 'i' ha un valore 'V[i]' e una capacità 'C[i]'. Trovare la lista di oggetti da dover prendere per massimizzare il valore complessivo degli oggetti potendoli trasportare in uno zaino di capienza 'n'.
Il problema è formulabile nella seguente maniera: "trovare il valore massimo dello zaino di capienza 'j' avendo a disposizione i primi 'i' oggetti".
Abbiamo il vettore 'V' lungo 'm' che parte dall'indice '1' e contiene il valore di ogni oggetto.
Abbiamo il vettore 'C' lungo 'm' che parte dall'indice '1' e contiene la capacità che occupa ogni oggetto.
Notiamo che sappiamo risolvere i problemi analoghi ma con capacità dello zaino uguale a zero; la soluzione di questi problemi è non prendere nessun oggetto (anche perché non è possibile fare altro) per un valore massimo dello zaino di zero.
Notiamo che sappiamo risolvere i problemi analoghi ma con disponibilità di zero oggetti; la soluzione di questi problemi è non prendere nessun oggetto (anche perché non è possibile fare altro) per un valore massimo dello zaino di zero.
Costruiamo una matrice 'M' di altezza 'm+1' e lunghezza 'n+1' che parte dagli indici '0, 0' e contiene, in ogni cella di indice 'i, j' il valore massimo che lo zaino di capienza 'j' può assumere, potendo selezionare i primi 'i' oggetti a disposizione.
Notiamo così che alla cella di indice 'm, n' risiede il valore massimo che è possibile ottenere riempiendo uno zaino di capacità 'n' avendo a disposizione i primi 'm' oggetti. Ma questo problema è proprio quello che dobbiamo risolvere, o meglio, una parte di esso. Infatti prima occorre trovarci il valore massimo dato dalla somma dei valori degli oggetti da dover prendere, per poi individuare gli oggetti che costituiscono questo valore massimo.
La programmazione dinamica ci permette di capire qual è il valore massimo, riempiendo la tabella, per poi capire quali oggetti hanno composto il valore massimo, ripercorrendo la tabella all'indietro (tabella=matrice).
Capiamo come ottenere la tabella. Di seguito il codice dell'algoritmo e poi i commenti.







Knapsack(V, C, n):
	# inizializzo la matrice che mi servirà per trovare il valore massimo del problema 'i, j' ma anche tutti i valori massimi dei problemi più piccoli
	M <-- matrice di grandezza m+1, n+1 con indici che partono da 0, 0
	# risolvo i casi base, ovvero i problemi immediatamente risolvibili
	FOR j from 0 to n:          # n compreso
		M[0][j] = 0
	FOR i from 0 to m:        # m compreso
		M[i][0] = 0
	# da notare che in questo caso avrei potuto evitare di risolvere i casi base come appena fatto, inizializzando la matrice M semplicemente con tutti zeri
	# ora riempio la matrice come segue così da ottenere tutte le soluzioni di ogni problema che è possibile identificare. 
	# Da notare che ogni cella i, j corrisponde ad un problema e la soluzione risiede nella cella stessa e rappresenta il valore massimo raggiungibile grazie alla possibilità di prendere i primi 'i' oggetti avendo uno zaino di capacità 'j' con l'obiettivo di massimizzare il valore che lo zaino può contenere grazie agli oggetti presi (questi oggetti hanno un valore proprio e una propria capacità che vanno ad occupare)
	FOR i from 1 to m:                   # m compreso
		FOR j from 1 to n:         # n compreso
			# visito tutte le celle i, j
			# ora ci troviamo nel problema i, j dopo che abbiamo risolto già tutti i problemi che si sono preceduti al  problema i, j
			# ad esempio conosciamo la soluzione del problema i-1, j e quella del problema i, j-1
			# ora abbiamo un oggetto in più (i) rispetto al problema i-1, j e la stessa capacità j del problema i-1, j
			# occorre capire se, prendendo l'oggetto i riusciamo a migliorare il valore massimo ottenuto dal problema i-1, j che ha la stessa capacità (j) ma l'assenza del nuovo oggetto i
			# quindi verifichiamo innanzitutto se la capacità di i (C[i]) è consona con la capacità j dello zaino (ovvero che non sia superiore) 
			IF C[i] > j:
				# in questa casistica l'unica scelta da percorrere è quella di non prendere il nuovo oggetto i
				# quindi la soluzione del problema i, j conoscendo la soluzione del problema i-1, j è facilmente ottenibile, perché è la stessa soluzione siccome non è possibile prendere in alcun modo il nuovo oggetto i
				M[i][j] = M[i-1][j]
			ELSE:
				# in questo caso abbiamo la possibilità di prendere oppure no il nuovo oggetto i per poter migliorare oppure no la soluzione del problema i-1, j
				# se non prendiamo il nuovo oggetto significa che prendendolo non è possibili migliorare la soluzione del problema i-1, j che già abbiamo
				# quindi in questo caso il nuovo oggetto i non si è rivelato utile per aumentare il valore massimo che è possibile contenere nello zaino di capacità j
				# se invece prendiamo il nuovo oggetto significa che prendendolo è possibile migliorare la soluzione del problema i-1, j che già abbiamo
				# quindi in questo caso il nuovo oggetto i si è rivelato utile per  aumentare il valore massimo che è possibile contenere nello zaino di capacità j
				# La scelta di prendere o meno l'oggetto si basa quindi sulla possibilità o meno che prendendo l'oggetto i avendo capienza j si migliori il valore massimo del problema i-1, j
				# questa scelta viene decisa dal seguente rigo:
				M[i][j] = max( M[i-1][j], V[i] + M[i-1][j-C[i]] )
				# M[i-1][j] significa non prendere l'oggetto i nel problema i, j 
				# quindi in M[i][j] ci sarà il valore massimo del problema i, j ovvero il valore massimo del problema i-1, j ovvero il valore nella cella M[i-1][j]
				# V[i] + M[i-1][j-C[i]] significa prendere l'oggetto i nel problema i, j
				# quindi in M[i][j] ci sarà il valore dell'oggetto appena preso più il valore massimo del problema M[i-1][j-C[i]], ovvero il valore massimo ottenibile avendo a disposizione uno zaino di capacità j-C[i], ovvero la capacità che resta dello zaino di capacità j dopo aver preso l'oggetto i, avendo a disposizione i primi i-1 oggetti, siccome l'oggetto i non è più disponibile perché è stato appena preso.
				# in M[i][j] viene quindi messo M[i-1][j] se M[i-1][j] >= M[i-1][j-C[i]], e questo equivale a non prendere l'oggetto i,
				# oppure in M[i][j] viene messo M[i-1][j-C[i]] se M[i-1][j-C[i]] < M[i-1][j], e questo equivale a prendere l'oggetto i
				# notiamo che se prendiamo l'oggetto i nel problema i, j, la cella M[i][j] differisce dalla cella M[i-1][j], più precisamente M[i][j] ha un valore maggiore rispetto a M[i-1][j]
				# invece se non prendiamo l'oggetto i nel problema i, j, la cella M[i][j] è uguale alla cella M[i-1][j]
				# queste ultime due riflessioni ci serviranno in seguito quando dovremmo identificare quali oggetti sono stati presi per ottenere il valore ottimale della casella i, j (i, j in modo generico)
	# alla fine del doppio ciclo di FOR la matrice è stata riempita correttamente con i valori massimi per ogni singola casella i, j
	# occorre adesso trovare gli oggetti che hanno totalizzato il valore massimo per il problema m, n, che è il nostro quesito iniziale
	# ci ricordiamo l'osservazione fatta in precedenza: nel problema i, j, se l'oggetto i è stato preso, vuol dire che M[i][j] è diverso da M[i-1][j], nello specifico, se si tratta di un problema di massimizzazione M[i][j] sarà maggiore di M[i-1][j], oppure minore se si tratta di un problema di minimizzazione
	# possiamo quindi formulare il seguente codice con relativi commenti:
	# ricordiamoci che la matrice ha altezza m+1 e lunghezza n+1, che parte dagli indici 0, 0 e che gli oggetti sono m e la capacità dello zaino è n
	# settiamo l'indice j all'ultima cella per la sua dimensione, ovvero n
	j = n
	# SOL è l'insieme che conterrà gli oggetti (tra gli m a disposizione) che vanno presi per massimizzare il valore dello zaino di capacità n. Per esattezza conterrà gli indici delle righe della matrice che corrisponderanno a quegli oggetti
	SOL = {}
	# settiamo l'indice i all'ultima cella per la sua dimensione, ovvero m
	# la i verrà decrementata per interrogare una riga alla volta (riga i) in modo distinto, e capire se l'oggetto i è stato preso
	for i from m to 1:      # 1 compreso
		# con il seguente IF capiamo se l'oggetto alla riga i è stato preso
		IF M[i][j] != M[i-1][j]:
			# se è stato preso allora memorizziamo l'indice i che corrisponde al rigo dell'oggetto
			SOL.add(i)
			# decrementiamo j perchè, avendo preso l'oggetto i, il nostro problema ora diventa: capire quali oggetti sono stati presi per massimizzare lo zaino di capacità j-C[i] con gli i-1 oggetti a disposizione
			j -= C[i]
	# notiamo che ad ogni decremento di j, la formulazione del problema riduce la capacità dello zaino e ad ogni decremento di i, la formulazione del problema riduce gli oggetti a disposizione
	RETURN SOL














# Codice Knapsack problem senza commenti

Knapsack(V, C, n):
	M <-- matrice di grandezza m+1, n+1 con indici che partono da 0, 0
	FOR j from 0 to n:
		M[0][j] = 0
	FOR i from 0 to m:
		M[i][0] = 0
	FOR i from 1 to m:
		FOR j from 1 to n:
			IF C[i] > j:
				M[i][j] = M[i-1][j]
			ELSE:
				M[i][j] = max( M[i-1][j], V[i] + M[i-1][j-C[i]] )
	j = n
	SOL = {}
	for i from m to 1:
		IF M[i][j] != M[i-1][j]:
			SOL.add(i)
			j -= C[i]
	RETURN SOL
