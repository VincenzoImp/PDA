- Un sotto insieme X di archi di un grafo diretto è detto aciclico se non esiste un ciclo con tutti gli archi contenuti in X.
Dare lo pseudocodice di un algoritmo che accetta in input un grafo G diretto e restituisce un insieme X di archi di grandezza al minimo |E(G)/2|

SOLUZIONE:
Idea: per ogni nodo del grafo faccio partire una visita (DFS), e poi controlla l'insieme dei  SOL, se è della dimensione corretta ritornalo 

for ogni nodo u di G:
	z=TROVAX(u)
	if len(z)>=(|E(G)/2|):
		return z

TROVAX(u):
	VIS=[]	//array dei nodi visitati a partire da u
	SOL=[]	//array da restituire in input
	S:stack
	VIS.add(u)
	S.push(u)
	while S not empty: 
		v=S.top()
		for ogni nodo w adicente di u:
			if w not in VIS:
				SOL.push({v,w})
				VIS.add(w)
				S.push(w)
			S.pop()
	return SOL








- Sia A un array di lunghezza n con n dispari, A è ordinato in cui ogni elemento tranne uno occorre esattamente 2 volte, dare lo pseudocodice di un algoritmo che in tempo O(log n) prenda in input l'array A e trova il valore unico. Esempio in A=[2,2,5,5,7,9,9,10,10] ritorna 7 e in A=[1,1,4,4,6,6,8,8,9] ritorna 9

SOLUZIONE:
Idea: utilizzare una tecnica divide et impera
i inizio intervallo
j fine intervallo
UNICO(A, i, j):
	if i<j:
		return 0
	else if i==j:
		return A[i]
	else:
		m=(i+j)/2 (parte intera superiore)
		if A[m]!=A[m-1] AND A[m]!=A[m+1]:
			return A[m]
		else if A[m]==A[m+1]:
			UNICO(A,m+1,j)
		else:
			UNICO(A,i,m)


MODIFICATO
- Dare lo pseudocodice per risolvere il seguente problema: dati n oggetti x1,x2...xn ognunno di costo ci e un valore vi, e dato un vincolo A trovare il sottoinsieme degli oggetti di costo minimo con valore totale al minimo A

SOLUZIONE:
Idea: tecnica greedy, ordinare l'array dei costo in modo crescente e prendere sempre il minimo finché A non diventa <=0

M matrice (n+1)x(A+1)
for i=0 to A+1:
	M[0][i]=infinito
for i=0 to n+1:
	M[i][0]=0
for i=1 to n+1:
	for j=1 to A+1:
		M[i][j]=min(M[i-1][j], M[i-1][max(0, j-V[i-1])]+C[i-1])
		
		/*oppure dentro i for va messo questo schifo
		if V[i-1]<=j:
			M[i][j]=min(M[i-1][j], M[i-1][j-V[i-1]]+C[i-1])
		else:
			M[i][j]=min(M[i-1][j], M[i-1][0]+C[i-1])
		*/
i=n+1
j=A+1
sol=set()
while i>0:
	if M[i][j]!=M[i-1][j]:
		sol.add(i-1)
		j-=V[i-1]
	i--
return sol









- Dato A un array di lunghezza n, un'inversione in A è una coppia di indici (i,j) tale che i<j e A[i]>A[j]. Esempio dato A=[6,5,4,8] un'inversione è (2,3), dare lo pseudocodice che trova il numero di inversioni in un array (nel caso dell'esempio 3) in tempo O(n(log n)^2)

SOLUZIONE:	
Idea: spezza l'array in due (X e Y) ordina l'array X per ogni elemento y in Y effeetua una ricerca binaria in X per scoprire quanti elementi di X sono più grandi di y

Idea: sfuttare una variante del merge, divido ricorsivamente l'array in due e controllo tramite una funzione quante inversioni ci sono nelle due parti,e poi quelle a cavallo

INVERSIONIMONTI(A, i, j):
	if j<i:
		return 0
	if i==j:
		return 0
	else:
		m=(i+j)/2
		x=INVERSIONIMONTI(A, i, m)
		y=INVERSIONIMONTI(A, m+1, j)
		a=i
		b=m+1
		z=0
		while a<=m OR b<=j:
			if A[a]<A[b]:
				a=a+1
			else
				z=z+m+1-a
				b=b+1
	MERGE(i, m, j)
	return x+y+z


CONTA(A, i, j):
	if len(A)==0:
		return 0
	else if len(A)==1
		return 0

	else:
		if i<j:
			m=(i+j)/2
			x=CONTA(A, i, m)
			y=CONTA(A, m+1, j)
			z=INVERSIONI(i, m, j)
	inverisoni=x+y+z
	return inversioni

INVERSIONI(A, arr[], start, mid, end):
	i=start
	j=mid
	k=left
	c=0
	while i<=mid AND j<=end:
		if A[i]<=A[j]:
			arr[k]=A[i]
			k=k+1
			i=i+1
		else
			arr[k]=A[j]
			c=c+(mid-i+1)
			k=k+1
			j=j+1
	while i<=mid:
		arr[k]=A[i]
		k=k+1
		i=i+1
	while j<=end
		arr[k]=a[j]
		k=k+1
		j=j+1
	return c

INVERSIONE(A):	//costo O(n^2)
	inversioni=0
	for i=1 to n-1:
		for j=i to n:
			if A[i]>A[j]:
				inversioni=inversioni+1
	return inversioni











- Siano date n scatole, ogni scatola Si è descritta da una tripla (xi,yi,zi) le cui componenti denotano rispettivamente lunghezza altezza e larghezza delal scatola. La scatola Si può essere inserita nella scatola Sj se e solo se le sue dimensioni lo permettono senza rotazioni ovvero xi<xj, yi<yj, zi<zj.
Descrivere un algoritmo basato sulla programmazione dinamica che in tempo O(n^2) determina il numero massimo di scatole che possono essere inserite una dentro l'altra senza rotazioni, esempio per le 6 scatole:
S: 1 2 3 4 5 6
X: 4 5 4 1 1 6
Y: 4 6 3 1 2 1
Z: 4 4 3 6 1 4

la ristposta è 3 perché posso prendere le scatole S5<S3<S2 
NOTA: si può assumere che le scatole siano ordinate rispetto a duna delle cdimesioni 

SOLUZIONE:
Idea: il problema è simile al problema di trovare la più lunga sottosequenza crescente dove anziché verificare solo xj e xi verifico contemporaneamente x y e z.
Definizamo quindi con N[j] il massimo numero di scatole S (fino alla scatola j) che possono essere inserite considerando la scatola Sj come quella più esterna, N[j]=1 nel caso nessuna delle precedenti scatole poossa essere inserita dentro Sj. Supponiamo invece che la scatola i-esima con i<j possa essere inserita dentro Sj, facendo ciò otterremo N[i]+1 scatole che possono essere inserite l'ìuna dentro l'altra, in quanto sappiamo che è possibile inserire N[i] scatole usando Si come scatola più esterna.
Quindi tra tutte le scatole si che che possono essere inserite dentro sj, scegliamo quella per cui il valore N[i]+1 risulta massimo possibile. 

SCATOLE(S, D=(x,y,z)):

	N=[]: array da 1 ad n tale che N[k]=massimmo numero di scatole che possono essere inserite usando la scatola Sk come esrena
	Nmax: valore massimo di N

	ordina le scatole secondo una delle dimensioni
	N[1]=1
	Nmax=1
	for i=2 to n:
		max=0
		for j=1 to i-1:
			if (xj<xi) AND (yj<yi) AND (zj<zi) AND (N[j]+1>max)
				max=N[j]+1
		if max>Nmax:
			Nmax=max
	return Nmax









- Dato P il vettore dei padri di un albero di n nodi , dare lo pseudocodice di un algoritmo che in tempo O(n) restituisca DIST, il vettore delle distaze di ogni nodo dalla radice

SOLUZIONE:

	DIST: vettore delle distanze inizializzato a -1
	for ogni nodo u:
		if DIST[u]==-1:
			TROVADISTANZE(u)
	return DIST

TROVADISTANZE(u):
	if u==P[u]:
		DIST[u]=0
	else if DITS[P[u]]==-1:
		TROVADISTANZE(P[u])
		DIST[u]=DIST[P[u]]+1
	else:
		DIST[u]=DIST[P[u]]+1








MODIFICATO
- Dato un grafo G con pesi sugli archi, il peso di un ciclo è la somma dei pesi degli archi, dare lo pseudocodice di un algoritmo che prenda in input un grafo diretto e pesato e trovi il ciclo di peso minimo, l'algoritmo deve avere costo O(m(n+m)log n)
SUGGERIMENTO: cercare prima di trovare il peso di un ciclo che contiene un arco fisso (u,v) 

min=+infinito
lista=[]
for ogni arco (u,v) di G:
	L,c=CILOMINIMO(G, u, v)
	if c<min:
		min=c
		lista=L
	return lista min

CILOMINIMO(G, u, v):
	P,D=Dijkstra(G,v)
	if D[u]!=+infinito:	//siamo riusciti ad andare da v ad u
		return GETLISTA(P,u,[]), D[u]+peso(u,v)
	return [], +infinito

GETLISTA(P,u,L):
	L.append(u)
	if P[u]!=u:
		getlista(P[u])
	return L










- Dato un array A di interi di lungo n, trovare in tempo O(log n) un minimo locale ovvero un numero tale che A[i]<=A[i-1], oppure A[1]<=A[2] o A[n]<=A[n-1], esempio se A=[5,6,7,5,9], allora i minimi loclai sono A[1] e A[4]

SOLUZIONE:
Idea: Confrontiamo l'elemento centrale con i suoi vicini. Se l'elemento centrale non è maggiore di nessuno dei suoi vicini, allora lo restituiamo. Se l'elemento centrale è maggiore del suo vicino sinistro, allora c'è sempre un minimo locale nella metà sinistra. Se l'elemento centrale è maggiore del suo vicino destro, allora c'è sempre un minimo locale nella metà destra.

LOCAL(A, i, j):
	if j<i:
		return 0
	else if i==j:
		return A[i]
	else if A[1]<=A[2]:
		return A[1]
	else:
		m=(i+j)/2
		if A[m]<A[m-1] and A[m]<A[m+1]:
			return A[m]
		if A[m]>A[m-1]:
			LOCAL(A, i, m)
		eles:
			LOCAL(A, m+1, j)









MODIFICATO
- Una passeggiata è un cammino che potrebbe ripeteere vertici ed archi, dare lo pseudocodice di un algoritmo che preso un grafo diretto G, due vertici u e v e un intero k restituisca il numero di passeggiate distinte di lunghezza al massimo k da u a v, l'algoritmo deve avere complessità O(nmk)

SOLUZIONE:

MAIN(G, u, v, k):
	c=0 		//contatore degli archi che vengono visitati che scandiscono la lunghezza del percorso
	count=0		//contatore dei percorsi lunghi k da u a v
	return CAMMINI(G, u, v, k, c, count)

CAMMINI(G, node, end, k, c, count):
	if c<k:
		for ogni w adj(node):
			if w==end AND c+1<=k:
				count++
			else:
				count=CAMMINI(G, w, end, k, c+1, count):
	return count

complessitá: la funzione scorre ogni nodo, e per ogni nodo si scorrono gli adiacenti, questo puó succeredere k volte. O(nmk)
ispirazione: https://www.geeksforgeeks.org/count-possible-paths-source-destination-exactly-k-edges/










- Sia A un array di n elementi che non possono essere ordinati (es. stringhe), un elemento maggioritario è un elemento che occorre almeno n/2 volte nell'array, dare lo pseudocodice di un algoritmo che trova un elemento maggioritario in tempio O(n log n)

SOLUZIONE:
Idea: utilizzare un dizionario con chiave l'elemento e valore il numero di occorrenze

MAGGIORITARIO(A):
	d={}	//dizionario con chiave gli elementi e valore ilò numero di occorrenze
	if n==0:
		return 0
	else if n=1:
		return A[1]
	else:
		foir i=1 to n:
			if i in d:
				d[i]+=1
			else:
				d[i]=1

	x=d.getmax()
	if x>n/2:
		return "YES"
	

MAGGIORITARIO2(A):
	elem=NULL
	c=0
	count=0
	for i=1 to n:	//scansione che trova il candidato
		if A[i]==e:
			c=c+1
		else if c>0:
			c=c-1
		else:	
			e=A[i]
			c=1

	for i in e:		//Scansione che controlla se il candidato è mggioritario
		if A[i]==e:
			count+=1
	if count>n/2:
		return "YES"
	








CONTROLLATO
- Dato un albero di n nodi rappresentato tramite vettore dei padri P, e due nodi dell'albero u e v dare lo pseudocodice di un algoritmo che in tempo O(n) trova la distanza tra u e v, esempio se P=[2,2,1,2,4,3,3,9,1] e u=9 e v=3 deve restituire 2 se invece u=3 e v=6 deve restituire 1

SOLUZIONE:

lista_antenati(P, x, S)
	S.push(x)
	if P[x]!=x:
	  return lista_antenati(P, P[x], S)
	return S

distanza_uv(P, u, v)
	  if u==v: return 0
	  L1=lista_antenati(P, u, Stack vuoto)
	  L2=lista_antenati(P, v, Stack vuoto)
	  len1=len(L1)
	  len2=len(L2)
	  i=0
	  while len1>0 and len2>0 and L1[i]==L2[i]:
	    len1--
	    len2--
	    i++
	  return len1+len2











MODIFICATO
- Date monete con valori 1,5,10,25 dare lo pseuidocodice di un algoritmo che da il resto R usando il minimo numero di monete, dare un esempio di possibili valori per cui l'algorritmo greedy non funziona

RESSTO(A,R)
	ordina A in ordine DEcrescente
	c=0
	for i=1 to n:
		if A[i]<=R:
			c++
			R=R-A[i]
	return c	













- Sia A un array di n lementi ordinato, dare lo pseudocodice di un algoritmo che con complesistà O(log n) prenda in input A e un valore x e restitusce il numero di indici j per il quale A[j]=x, per sempio se A=[1,1,,2,3,3,3,3,,4,4,5,6] con x=3 restitusice 4

SOLUZIONE:

INDEX(A, x, i, j):

	if i==j:
		if A[i]==x:
			return 1
		else: 
			return 0
	else if j<i:
		return 0
	else:
		m=(i+j)/2
		if A[m]==x:
			return 1
	return INDEX(A, x, i, m)+INDEX(A, x, m+1, j)









CONTROLLATO
- Si supponga di dover effettuare un viaggio dalla località A alla località B con un auto che ha un’autonomia di k chilometri. Lungo la strada ci sono n+1 distributori di benzina ciascuno distante dal precedente meno di k chilometri. Sia di la distanza che separa il distributore i dal distributore i+1 per i=1,2,… n, dove il distributore 1 è in A e il distributore n+1 è in B. Inizialmente il serbatoio dell'auto è vuoto. Descrivere un algoritmo greedy che preso in input la lista delle distanze d1,…dn dei distributori, seleziona un numero minimo di distributori in cui far rifornimento durante il viaggio. 

SOLUZIONE:

RIFORNIMENTI(d, k):    //d array delle distanze, k autonomia

	SOL=[]   //array edi distributori in cui ci si è fermati inizialmente vuoto
	aut=0
	for i=1 to n:
	    if aut<d[i]:    //se non si può rggiungere il prossimo distributore
	        aut=k    //fai rifornimento
	        SOL[i]=1
	    aut=aut-d[i]
	return SOL
	









CONTROLLATO
- A un girone di un torneo si può sceglierre tra n avversari, l'aversario vale P[i] punti e richiede uno sforzo S[i], descrivere un algoritmo ceh tramite la programmazione dinamica e che prende in input gli array di interi positivi P ed S e un valore Q sufficente per qualificarsi, dà in output un sottoinsieme di avversari che permette di qualificarsi con sforzo minimo

SOLUZIONE:

TORNEO(P, S, Q):
	M matrice Qxn
	for i=0 to Q:
		 M[0][i]=infinito
	for i=0 to n:
		 M[i][0]=0
	for i=1 to n:
	  for j=1 to Q:
	    M[i][j]=min(M[i-1][j], M[i-1][max(0, j-P[i])]+S[i])
	return M[i][j]

LISTA(M, Q, n):
	j=Q
	i=n
	sol=set()
	while i>0:
	  if M[i][j]!=M[i-1][j]:
	    sol.add(i-1)
	    j-=max(0, P[i-1])
	  i--
	return sol












- Dato un grafo G con archi sia diretti che non diretti, assumiamo che G non contenga cicli diretti, descrivere un algoritmo che assegna una direzione agli archi non diretti in G in modo da ottenere un grafo diretto G' privo di cicli, dare lo pseudocodice e analizzare la complessità

SOLUZIONE:
Idea: Ordino i nodi del grafo secondo un ordine topologico considerando solo gli archi diretti, posso farlo poichè il grafo non ha cicli diretti, successivamente assegna la direzione degli archi non diretti in modo tale che vadino da un nodo ordinato prima ad un successivo

CONSIDERO G COME UN DAG
	L=[]
	VIS=[]
	for ogni nodo v di G:
		if VIS[v]==0:
			ORDINA(G, v, L, VIS)
	return L

ORDINA(G, v, L, VIS);
	VIS[v]=1
	for ogni w adiacente di v:
		if VIS[w]==0:
			ORDINA(G, w, L, VIS)
	L.add(v)


DIREZIONE(L):
	for v in L:
		if v in G ha un arco senza direzione verso w:
			if v>w in L:	//v sempre maggiore di w perché sto scorrendo la lista in ordine
				arco={v,w}
		
COSTO: O(n(n+m))













MI FIDO TANTO É NORMALE PD
- Una pedina è posizionata sulla casella (1,1) in alto a sinistra di una chacchiera (nxn), deve raggiungere la casella (n,n), ci si può muovere solo nella casella (i+1,j) o nella casella (i,j+1) con i<n e j<n, la sequenza delle caselle toccate determina un cammino, ogni casella ha un colore c[i,j] che può essere rosso o verde, descrivere un algorotimo che in tempo O(n^2) calcola il numero di cammini che passano solo su caselle rosse e vanno dalla cella (1,1) a quella (n.n)

SOLUZIONE:

SCACCHIERA(S):
	M: matrice (nxn)
	for i=1 to n:
		if c[i,0]==R:	//il colore della casella è rosso
			M[i,0]=1
		else:
			M[i,0]=0

	for j=1 to n:
		if c[0,j]==R:	//il colore della casella è rosso
			M[0,j]=1
		else:
			M[0,j]=0
	for i=1 to n:
		for j=1 to n:
			if c[i,j]==R:
				M[i,j]=M[i-1,j]+M[i,j-1]
			else:
				M[i,j]=0
	return M[n,n]









- Si sta percorrendo una strada lunga L km con una fiaccola accesa, la fiaccola resta accesa per t km, lo scopo è di percorrere la strada (dal chilometro 0 al chilometro L) senza che la fiaccola si spenga. Lungo la strada ci sono n punti di sosta in cui si può riaccendere la fiaccola, il costo per riaccendere la fiaccola alla stazione i è C[i], le distanze delle stazioni sono date da un vettore D[1...n], dare lo pseudocodice di un algoritmo dio programmazione dinamica che calcoli il ocsto minimo del viaggio
######################????????????#########################
SOLUZIONE:

VIAGGIO(L, t, D, C):
	if L==0:
		return 0
	if n==0 and t<L:
		return 0
	if n==0 and t>L:
		return 1

	M: matrice (n+1xn+1)
	for i=0 to n:
		M[i,0]=0
	for j=0 to n:
		M[0,j]=0
	for i=1 to n:
		for j=1 to n:
			if t<D[i]:
				M[i,j]=min(M[i-1, L-j], M[i-1, L-j]+C[i])
			else:
				M[i,j]=M[i-1, L-j]
	return M[n,n]










- Dare lo pseudo-codice di un algoritmo che preso in input un grafo non diretto e connesso G, un suo nodo u, un vettore dei padri P relativo a una BFS da u in G e un arco {v, w} di G, ritorna True se e solo se la rimozione dell'arco {v, w} non cambia le distanze da u. L'algoritmo deve avere complessità O(n)

SOLUZIONE:
Idea: Se l'arco {v,w} non appartiene alla BFS la usa rimozione non cambia le distanze, se invece fa parte dell'albero o v è figlio di w o viceversa,  nel primo caso le distanze non cambiano se e solo se la distanza di v, dopo la rimozione di {v,w}, non aumenta e questo accade se e solo se esiste un adiacente x!=w di v tale che distanza(x)<distanza(v), il secondo caso è simmetrico

TROVADISTANZE(u):
	if u==P[u]:
		DIST[u]=0
	else if DITS[P[u]]==-1:
		TROVADISTANZE(P[u])
		DIST[u]=DIST[P[u]]+1
	else:
		DIST[u]=DIST[P[u]]+1


DIST=[]	//inizializzato a -1
DFSRIC(u):
	for ogni w adiacente di u:
		if DIST[w]==-1:
			DIST[w]=TROVADISTANZE(w)
	return DIST

CONTROLLO(G, u, P, {v,w}):
	if P[v]!=w AND P[w]!=v:		//{v, w} non fa parte dell'albero 
		return TRUE
	else:
		if P[v]==w:
			x=v
		else:
			x=w

		d=TROVADISTANZE(P)
		for ogni y adiacente a x:
			if {y,x}!={v,w} AND d[x]<d[y]:
				return TRUE
		return FALSE 










- Dato un insieme di intervalli chiusi trovare un sottoinsieme massimale di intervalli che si intersecano, per esempio dato {[1,2],[3,5],[4,5],[5,7]} l'algoritmo restituisce {[3,5],[4,5],[5,7]}

SOLUZIONE:
Idea: Se non sono già ordinati, ordinali prima per X crescente e poi per Y crescente, se si incontra una coordinata x significa che viene aggiunto un nuovo intervallo, quindi aggiornare il conteggio e se si incontra una coordinata y significa che viene sottratto un intervallo

INTERVAL1(A):
	SOL=[]
	maxinterval=0	//numero massimo di intervalli che si intersecano
	I=A[1]		//primo intervallo
	for i=2 in n:
		m=min(I.Y, i.Y)-i.X
		if m>maxinterval:
			SOL.add(I, i)
			maxinterval=m
		if i.Y>I.Y
			I=i
	return SOL


INTERVAL2(A):
	cunt=0
	m=0
	ordina l'array
	for i in range n:
		if cordinata(i)==x:
			count+=1
		if cordinata(i)==y:
			count-=1
		m=max(m, count)
	return m









MODIFICATO
- Dato un vettore di n interi A con A[1]<A[2]<...<A[n] vogliamo determinare in tempo O(log n) se esiste o meno un indice i per cui A[i]=i

SOLUZIONE:

PUNTOFISSO(A,i,j):
	if i==j:
		if A[i]=i:
			return TRUE
		else:
			return FALSE
	m=(i+j)/2	//parte intera inferiore
	if A[m]==m:
		return TRUE
	if A[m]<m:
		PUNTOFISSO(A,m+1,j)
	else:
		PUNTOFISSO(A,i,m):

MIAVERSIONE
indici partono da 1
ric(A, i):
	if A[i]==i:
		return true
	if i>1:
		i=i/2
		return ric(A[:i], i)
	return false









- Dato un intero x ad vettore A di n interi con A[1]<=A[2]<=...A[n], vogliamo determinare in tempo O(log n) il numero di occorrenze di x nel vettore A

SOLUZIONE:
Idea: con la ricerca binaria si calcola il numero a di elementi >x in A con la ricerca binaria calcoliamo il numero b di elementi <x in A restituiamo il numero di occorrenze di x in A dato da n-a-b

MINORI( A, i, j, x):
	if (i==j):
		if (A[i]<x):
			return i
		else:
			return i-1
	else:
		m=(i + j)/2 	(Parte intera inferiore)
		if (A[m]<x):
			 i=m+1 		//il numero di elementi minori di x è maggiore o uguale ad m
		else:
			j=m-1 //il numero di elementi minori di x è minore di m
		return  MINORI(A, i, j, x) //il numero di elementi minori di x è nell’intervallo [i  1, j]










- Dato un albero con radice r e vertici u,v,w, il minimo antenato comune LCA(u,v,w) è l'antenato comune dei tre nodi più recente, ovvero più lonatno dalla radice, dare lo pseudocodice di un algoritmo che prende in input un albero come vettore dei padri P e i vertici u,v,w e trova in (n) LCA(u,v,w)

SOLUZIONE:
Idea: mi calcolo il percorso dalla radice ai nodi interessati, scorro poi questi percorsi e non appena trovo un nodo diverso restisco quello precende

TROVAPERCORSO(e):
	path=[]		//array che contiiene il percorso
	if P[e]!=e:		//finchè il nodo è diverso da suo padre ovvero finche non arrivo alla radice
		path.add_hesd(e)	//inserisce in testa alal lista
		TROVAPERCORSO(P[e])
	return path

LCA(u, v, w):
	p1=TROVAPERCORSO(u)
	p2=TROVAPERCORSO(v)
	p3=TROVAPERCORSO(w)
	i=0
	while i<len(p1) AND i<len(p2) AND i<len(p3):
		if p1[i]!=p2[i]!=p3[i]:
			a=i-1
			break
		else:
			i=i+1
	if a<1:
		p1[a]=radice	//ovvero se hanno come unico antenato comune la radice
	return p1[a]









MODIFICATO
- Abbiamo n interi p1,p2,..pn odve pi rappresenta il prezzo a cui è possibile vendere un asta di lunghezza i, disponiamo di un'asta di lunghezza n e vogliamo rivenderla a pezzi o intera massimizzandone il ricavo, descrivere un algoritmo di programmazione dinamica che in tempo O(n^2) determina il ricavo massimo che è possibile ottenre, ad esempio per n=10 e 
p1 p2 p3 p4 p5 p6 p7 p8 p9 p10
 1  3  5  6  6  7  9 10 12 13 
il valore mssimo ceh si può ottenere è 16 (due da 3 ed una da 4) ,ottenere anche la lista delle lunghezze

SOLUZIONE:

n lunghezza dell'asta
P vettore dei prezzi P[i] prezzo dell'asta lunga i
M matrice (n+1)x(n+1)
for i=0 to n+1:
	M[i][0]=0
	M[0][i]=0
for i=1 to n+1:
	for j=1 to n+1:
		if i<=j:
			M[i][j]=max(M[i-1][j], M[i][j-i]+P[i])
		else:
			M[i][j]=M[i-1][j]
i=n+1
j=n+1
sol=set()
while i>0:
	if M[i][j]!=M[i-1][j]:
		sol.add(i-1)
		j-=(i-1)
	i--
return sol









CONTROLLATO
- Dare lo pseudocodice di un algoritmo che preso in input n intervalli chiusi [a,b] trova il numero di valori {x1,..,xk} tali che per ogni intervallo [a,b] esiste un punto di x che appartiene all'intervallo, tale insieme deve avere cardinalità minima in tempo O(nlog n)

SOLUIOZNE:

INTERVALS(A):	//A insieme degli inetrvalli
	ordina gli intervalli eper tempo di inizio crescente e di fine decrescente
	SOL=[]
	m=A[0].fine
	for i=2 to n:
		if A[i].inizio>m:
			SOL.add(A[i].fine)
	return SOL







CONTROLLATO
- Sia A[1...n] un array di interi con valori da 0 a K (quindi 0<=A[i]<=K per ogni indice i), dare lo pseudocodice di un algoritmo per trovare (X,Y) tale che |Sx-Sy| è minima dove Sx e Sy sono la osmma degli elementi (rappresentati dagli indici) di X ed Y, per esempio se A[1,3,1,1]  allora X=[1,3,4] (ovvero l'insieme formato da [1,1,1]) e Y=[2] (formatio dal solo elemento 3) è la soluzione ottima poiché Sx=3 e Sy=3, seA[2,2,3,2] X=[1,2] e Y=[3,4], poiché Sx=4 e Sy=5

SOLUZIONE:
FINDSETS(A):
	tot=0
	for i=0 to n:
		tot=tot+A[i]

	max=tot/2
	M: matrice n x max
	for i=0 to n:
		M[i][0]=0
	for i=0 to max: 
		M[0][i]=0
	for i=1 to n:
	  for j=1 to max:
	    if A[i]<=j:
	      M[i][j]=max(M[i-1][j], M[i-1][j-A[i]]+A[i])
	    else:
	      M[i][j]=M[i-1][j]
	j=max
	i=n
	set1=set()
	set2=set()
	while i>0:
	  if M[i][j]!=M[i-1][j]:
	    sol1.add(A[i-1])
	    j-=A[i-1]
	  else:
	    sol2.add(A[i-1])
	  i--
	return sol1, sol2







- Dato un array di numeri reali dare lo pseudocidice di un algoritmo per trovare l'insieme di cardinalità minima di intervalli di lunghezza uno (ovvero intervalli del tipo [x,x+1]) che contengono tutti gli elementi di A, per esempio dato A=[1.1,2.05,3,4] una soluzione sarebbe {[1.1,2.1] [3,4]}, la complessità deve essere O(n)

SOLUZIONE:
MAXINTERVALS(A):
	fSOL=[]
	SOL.ADD([A[0], A[0]+1])
	end=A[0]+1
	for i=1 to n:
		if A[i]<end
		SOL.ADD([A[i], A[i]+1])
		end=A[i]+1
	return SOL








CONTROLLATO
- Un cavallo bianco è posizionato nella casella (x1,y1) di una scacchiera nxn mediante una sequenza di mosse deve raggiungere il re nero nella casella (x2,y2), un cavallo nella casella (i,j) ha al più 8 mossse possibili: (i+1,j+2), (i+1,j-2), (i-1,j+2), (i+1,j-2) oppure (i+2,j+1), (i+2,j-1), (i-2,j+1), (i-2,j-1). descriverre un algoritmo per determinare che esiste una serie di mosse da (x1,y1) a (x2,y2) e se esiste trovare una con il nuemro minimo di mosse
	
SOLUZIONE:

cavallo(cavalloxy, pedonexy):
	P matrice dei padri iniziata a (0,0)
	D matrice delle distanze iniziata a infinito
	P[cavalloxy]=cavalloxy
	D[cavalloxy]=0
	Q coda vuota
	Q.insert(cavalloxy)
	WHILE Q!=vuoto:
		coppiaxy=Q.extract()
		FOR ogni mossaxy in get_possibili_mosse(coppiaxy):
			P[mossaxy]=coppiaxy
			D[mossaxy]=D[coppiaxy]+1
			Q.insert(mossaxy)
	return get_lista_percorso(P, pedonexy, L=[])

get_lista_percorso(P, coppiaxy, L):
	L.append(coppiaxy)
	IF P[coppiaxy]!=coppiaxy:
		return get_lista_percorso(P, P[coppiaxy], L)
	return L

get_possibili_mosse(coppiaxy):
	x=coppiaxy[0]
	y=coppiaxy[1]
	L=[]
	IF 0<x+1<9 AND 0<y+2<9:  L.append((x+1,y+2))
	IF 0<x+1<9 AND 0<y-2<9:  L.append((x+1,y-2))
	IF 0<x-1<9 AND 0<y+2<9:  L.append((x-1,y+2))
	IF 0<x-1<9 AND 0<y-2<9:  L.append((x-1,y-2))
	IF 0<x+2<9 AND 0<y+1<9:  L.append((x+2,y+1))
	IF 0<x+2<9 AND 0<y-1<9:  L.append((x+2,y-1))
	IF 0<x-2<9 AND 0<y+1<9:  L.append((x-2,y+1))
	IF 0<x-2<9 AND 0<y-1<9:  L.append((x-2,y-1))
	return L







- 1) Sia G un grafo diretto con n nodi ed m archi con almeno un ordinamento topologico, qual è il numero massimo di componenti fortemente connesse che G può avere?
 
2) Sia G un grafo orientato ottenuto da un albero di n nodi in cui ogni arco è stato orientato dal padre al figlio:
	a) Qual è il numero minimo di ordinamenti topologici che G può avere?
	b) Qual è il numero massimo di ordinamenti topologici che G può avere?

3) Si consideri un grafo G diretto ed aciclico con n nodi, qual è il numero massimo di archi che G può avere?

SOLUZIONE:

1) n, esempio in un albero degenere in cui ogni nodo è una componente a se stante
2)	a) 1, si pensi nuovamente ad un albero degenere in cui si prendeono i nodi dal primo all'ultimo
	b) (n-1)! la scelta della radice è obligata poi non cambia nulla, si pensi ad un qualunque albero 
3)	









CONTROLLATO ma la complessitá é diversa
- Sia G un grafo diretto con pesi positivi sugli archi, descrivere un algoritmo ceh trova il cammino di costo minimo tra due vertici u e v in G supponendo di avere un Jolly che ci permette di trasformare il peso di un singolo arco in 0, la complessità deve essere O(V log V+E)

JOLLY(G, s):
	P: vettore inizializzato a -1
	D: vettore delle distanze inizializzato a +infinito 
	Jolly: lista lunga n inizializzata a -1
	P[s]=s
	D[s]=0
	for ogni w adiacente ad s:
		P[w]=s
		D[w]=0
		Jolly[w]=[peso{s,w}]
	H:min-heap senza il nodo s in base alle distanze
	while H not empty:
		v=H.getmin()
		for ogni u adiacente a v:
			if Jolly(v)>=peso(v,u)
				if D[v]+peso({v,u})<D[u]
					P[u]=v
					D[u]=D[v]+peso({v,u})
					H.decrese(u, D[u])
					Jolly[u]=Jolly[v]
			else:
				if D[v]+Jolly[v]<D[w]:
					P[u]=v
					D[u]=D[v]+Jolly[v]
					Jolly[w]=peso({v,w})
					H.decrese(w, D[u])
	return D








------------------------------------------------------------------------------------------------------------------

- Descrivere un algoritmo che, dato un grafo non diretto e connesso G, trova un ordinamento dei nodi v1,v2,…,vn tale che eliminando i nodi in quell'ordine lascia sempre il grafo connesso. L’algoritmo deve avere complessità O(n + m).

SOLUZIONE:
Idea: considerare un albero di visita del grafo e eliminare i nodi iniziando da una foglia dell'albero e ad ogni passo eliminare una delle foglie dell'albero rimasto. In questo modo siamo sicuri che le eliminazioni non disconnettono il grafo perché non disconnettono l'albero. Quindi è sufficiente modificare una DFS per produrre la lista dei nodi nell'ordine in cui vanno eliminati

VIS=[]

ELIMINA(G, u, VIS, L):	//L lista dei nodi
	VIS[u]=1
	for ogni adiacente u di v:
		if VIS[v]==0:
			ELIMINA(G, v, VIS, L)
	L.append(u)

Siccome un nodo u viene aggiunto alla lista L solo quando la visita da u termina, siamo sicuri che in L sono già stati aggiunti (e quindi vengono prima di u nell'ordinamento) tutti i nodi del sottoalbero di u. Perciò quando u viene eliminato sono già stati eliminati tutti i nodi del suo sottoalbero di visita e u è una foglia dell'albero residuo. C



Un cammino da un nodo u a un nodo v si dice super-minimo se ha peso minimo tra tutti i cammini da u a v e inoltre tra tutti i cammini di peso minimo da u a v ha il minimo numero di archi. Dato un grafo pesato G tale che i pesi sono interi positivi, si vogliono trovare i cammmini super-minimi da un nodo s.

SOLUZIONE:
Idea: Dobbiamo modificare i pesi del grafo G ottenendo G' in modo tale che un cammino C di pari peso di un altro cammino C' in G ma che ha un minor numero di archi di C' pesi in G' meno di C, cioè p(C) = p(C') ma p'(C) < p'(C'). Questo significa che il numero di archi di un cammino deve contribuire al peso di un cammino in G'. Il peso di un cammino in G' dovrebbe quindi essere formato da due contributi: il peso che ha in G e il suo numero di archi. Ovviamente non possiamo semplicemente sommare questi due contributi perchè altrimenti potremmo far pesare di meno un cammino breve che pesa molto rispetto a un cammino lungo che pesa poco. Solamente a parità di peso (in G), il numero di archi del cammino deve fare la differenza. Osserviamo che al massimo il contributo relativo al numero di archi è pari a n-1, dato che un cammino può avere al massimo n-1 archi. Sappiamo che tutti i pesi in G sono ineteri positivi, così se moltiplichiamo i pesi degli archi per n avremo che anche i pesi dei cammini sono moltiplicati per n. Questo significa che due cammini C e C' che avevano pesi "consecutivi", cioè p(C') = p(C) + 1, adesso avranno pesi p'(C') = np(C') = np(C) + n = p'(C) + n. Quindi sono distanziati di n e abbiamo lo spazio per aggiungere il contributo relativo al numero di archi. In conclusione per ogni arco e, il nuovo peso è p'(e) = np(e) + 1. Così per un qualsiasi cammino C, p'(C) = np(C) + L(C), dove L(C) è il numero di archi di C. In questo modo abbiamo la garanzia che per qualsiasi due cammini C e C' con p(C) < p(C') si ha p'(C) = np(C) + L(C) < np(C) + n + L(C') ≤ p'(C'). E se invece hanno lo stesso peso in G, in G' quello con il minor numero di archi pesa di meno.












M matrice (n+1)x(T+1)
for i=0 to n:
	M[i][0]=0
for i=0 to T:
	M[0][i]=0
for i=1 to n:
	for j=1 to T:
		if |M[i-1][j]-j| > |M[i-1][max(0, j-A[i-1])]+A[i-1]-j|:
			M[i][j]=M[i-1][max(0, j-A[i-1])]+A[i-1]
		else:
			M[i][j]=M[i-1][j]
i=n
j=T
sol=set()
while i>0:
	if M[i][j]!=M[i-1][j]:
		sol.add(A[i-1])
		j-=A[i-1]
	i--
return sol
	


